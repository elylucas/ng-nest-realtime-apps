"use strict";(self.webpackChunkguide_generator=self.webpackChunkguide_generator||[]).push([[82],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=i,m=d["".concat(c,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2776:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:2},r="Socket Connections",s={unversionedId:"lab2/SocketConnections",id:"lab2/SocketConnections",title:"Socket Connections",description:"In the first lab, we saw how the various pieces of Socket.io and Nest fit",source:"@site/docs/lab2/SocketConnections.md",sourceDirName:"lab2",slug:"/lab2/SocketConnections",permalink:"/ng-nest-realtime-apps/lab2/SocketConnections",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/ng-nest-realtime-apps/lab2/getting_started"},next:{title:"Joining and Leaving Rooms",permalink:"/ng-nest-realtime-apps/lab2/JoiningAndLeavingRooms"}},c={},l=[{value:"Nest",id:"nest",level:2},{value:"ChatService",id:"chatservice",level:3},{value:"ChatGateway",id:"chatgateway",level:3},{value:"Angular",id:"angular",level:2},{value:"ChatService",id:"chatservice-1",level:3},{value:"AppComponent",id:"appcomponent",level:3},{value:"AppComponent Template",id:"appcomponent-template",level:3}],p={toc:l};function h(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"socket-connections"},"Socket Connections"),(0,i.kt)("p",null,"In the first lab, we saw how the various pieces of Socket.io and Nest fit\ntogether to establish a real-time connection to the Angular client. In this lab,\nwe will take it a step further and properly organize the code into services that\nwill separate areas of concern."),(0,i.kt)("p",null,"Let's start by building out the server side."),(0,i.kt)("h2",{id:"nest"},"Nest"),(0,i.kt)("p",null,"On the server side, the Nest ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService")," will be responsible for maintaining\nthe state and the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatGateway")," will be responsible for communicating with the\nclient."),(0,i.kt)("h3",{id:"chatservice"},"ChatService"),(0,i.kt)("p",null,"To start building out the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService"),", we'll be adding a few methods to keep\ntrack of users when they connect and disconnect from the app."),(0,i.kt)("p",null,"Open the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService")," file and replace its contents with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=./server/src/chat/chat.service.ts",title:"./server/src/chat/chat.service.ts"},"import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ChatService {\n  users: Record<string, string> = {};\n\n  identify(user: string, clientId: string) {\n    this.users[user] = clientId;\n  }\n\n  disconnect(clientId: string) {\n    //look up user by clientId:\n    const users = Object.keys(this.users);\n    let userToRemove = '';\n    users.forEach((user) => {\n      if (this.users[user] === clientId) {\n        userToRemove = user;\n        return;\n      }\n    });\n    if (userToRemove) {\n      delete this.users[userToRemove];\n    }\n    return userToRemove;\n  }\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"identify")," method will get called immediately after the user makes a\nwebsocket connection. Its purpose is to keep track of the user's ",(0,i.kt)("inlineCode",{parentName:"p"},"clientId"),",\nwhich is randomly generated each time a client makes a new connection. In your\napplications, you will want a way to associate a ",(0,i.kt)("inlineCode",{parentName:"p"},"clientId")," with a user, as you\nwill need the ",(0,i.kt)("inlineCode",{parentName:"p"},"clientId")," to send individual messages to users. Our chat app uses\na plain JavaScript object where the user's name will be the key and the\n",(0,i.kt)("inlineCode",{parentName:"p"},"clientId")," the value."),(0,i.kt)("p",null,"The gateway will call the disconnect method when a websocket loses its\nconnection. When the disconnect happens, we only get the ",(0,i.kt)("inlineCode",{parentName:"p"},"clientId"),", which we\nthen search through the ",(0,i.kt)("inlineCode",{parentName:"p"},"users")," map to locate the user by the ",(0,i.kt)("inlineCode",{parentName:"p"},"clientId"),", and if\nwe find one, we remove the association."),(0,i.kt)("h3",{id:"chatgateway"},"ChatGateway"),(0,i.kt)("p",null,"Update the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatGateway")," to the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=./server/src/chat.gateway.ts",title:"./server/src/chat.gateway.ts"},"import { SubscribeMessage, WebSocketGateway } from '@nestjs/websockets';\nimport { ChatService } from './chat/chat.service';\nimport { Socket } from 'socket.io';\n\n@WebSocketGateway({ namespace: 'chat', cors: true })\nexport class ChatGateway {\n  constructor(private chatService: ChatService) {}\n\n  @SubscribeMessage('identify')\n  async handleIdentify(client: Socket, user: string) {\n    this.chatService.identify(user, client.id);\n  }\n\n  @SubscribeMessage('disconnect')\n  async handleDisconnect(client: Socket) {\n    this.chatService.disconnect(client.id);\n  }\n}\n")),(0,i.kt)("p",null,"We learned how to set up a gateway using the ",(0,i.kt)("inlineCode",{parentName:"p"},"@WebsocketGateway")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"@SubscribeMessage")," decorators in the last lab. One subtle difference, though,\nis we are specifying a namespace for our connection. Namespaces are a lot like\npaths in the URL for HTTP connections. When we specify a namespace, this gateway\nwill only be responsible for messages that get passed to this namespace."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"handleIdentify")," method will be called by the client immediately after\nmaking a connection. We grab the ",(0,i.kt)("inlineCode",{parentName:"p"},"clientId")," off the socket and pass it to the\nservice to keep track of the user."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"handleDisconnect")," method is a lifecycle event of Socket.IO and\nautomatically gets called when the client disconnects. In this instance, we\ncollect the ",(0,i.kt)("inlineCode",{parentName:"p"},"clientId")," and pass it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService")," to remove the user from\nour list of currently connected users."),(0,i.kt)("p",null,"With the Nest files set up, let's shift our focus to the client side."),(0,i.kt)("h2",{id:"angular"},"Angular"),(0,i.kt)("p",null,"On the client side, the Angular ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService")," will be responsible for setting up\nthe Socket.IO connection with the backend and maintain client-side state of our\napp."),(0,i.kt)("h3",{id:"chatservice-1"},"ChatService"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService")," will be handling a bit of data, and we will be storing that\nstate using RXJS\n",(0,i.kt)("a",{parentName:"p",href:"https://rxjs.dev/api/index/class/BehaviorSubject"},"BehaviorSubjects"),".\nBehaviorSubject is a good choice for real-time data because we can notify any\nsubscribers when the data is changed, and they are guaranteed to get a value\nupon subscription."),(0,i.kt)("p",null,"We could return each piece of data as its own observable, which could get\ncumbersome for our subscribers. So instead, we'll combine all the\nBehaviorSubjects into a single observable and expose it through a\n",(0,i.kt)("inlineCode",{parentName:"p"},"getChatAppData()")," method."),(0,i.kt)("p",null,"Update the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService")," with the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=./client/src/app/chat.service.ts",title:"./client/src/app/chat.service.ts"},"import { Injectable } from '@angular/core';\nimport { BehaviorSubject, combineLatest, map, Observable } from 'rxjs';\n\nexport interface ChatAppData {\n  connected: boolean;\n  user: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ChatService {\n  private connected$ = new BehaviorSubject(false);\n  private user$ = new BehaviorSubject('');\n\n  constructor() {}\n\n  getChatAppData(): Observable<ChatAppData> {\n    const data = combineLatest([this.connected$, this.user$]).pipe(\n      map((value) => {\n        const [connected, user] = value;\n        return {\n          connected,\n          user,\n        };\n      })\n    );\n    return data;\n  }\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatAppData")," interface defines what data the service exposes. We will start\noff with a boolean ",(0,i.kt)("inlineCode",{parentName:"p"},"connected")," property, which defines if there is a current\nSocket.IO connection, as well as a ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," property, which will contain the\nuser's name. We'll be adding to this data structure more in the following\nlessons."),(0,i.kt)("p",null,"Next, we define two class members, ",(0,i.kt)("inlineCode",{parentName:"p"},"connected$")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"user$"),", which are\nBehaviorSubjects and maintain the value for their respective variables from\n",(0,i.kt)("inlineCode",{parentName:"p"},"ChatAppData"),"."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"getChatAppData")," method, we use RXJS's ",(0,i.kt)("inlineCode",{parentName:"p"},"combineLatest")," function to\ncombine all the BehaviorSubjects into a single observable that can be subscribed\nto once."),(0,i.kt)("p",null,"Now that the state is set up, let's add the code required to establish a\nconnection and update the values."),(0,i.kt)("p",null,"Modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"ChatService"),", adding or updating the highlighted lines (some\nexisting code omitted for brevity):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=./client/src/app/chat.service.ts",title:"./client/src/app/chat.service.ts"},"//highlight-next-line\nimport { io, Socket } from 'socket.io-client';\n\nexport interface ChatAppData {\n  connected: boolean;\n  user: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ChatService {\n  //highlight-start\n  private url = 'http://localhost:3000/chat';\n  private client: Socket;\n  //highlight-end\n\n  //highlight-start\n  constructor() {\n    this.client = io(this.url, { autoConnect: false });\n\n    this.client.on('connect', () => {\n      this.client.emit('identify', this.user$.value);\n      this.connected$.next(true);\n    });\n    this.client.on('disconnect', () => {\n      this.connected$.next(false);\n    });\n\n    const user = localStorage.getItem('user') || '';\n    if (user) {\n      this.connect(user);\n    }\n  }\n\n  connect(user: string) {\n    if (this.client.connected) {\n      return;\n    }\n    localStorage.setItem('user', user);\n    this.user$.next(user);\n    this.client.connect();\n  }\n\n  disconnect() {\n    localStorage.removeItem('user');\n    this.client.disconnect();\n    this.user$.next('');\n  }\n  //highlight-end\n}\n")),(0,i.kt)("p",null,"First, we add a ",(0,i.kt)("inlineCode",{parentName:"p"},"url"),' member that contains the URL to connect to. Notice the URL\nends with "/chat", which specifies the namespace and corresponds to what was set\nup in the Nest gateway on the ',(0,i.kt)("inlineCode",{parentName:"p"},"@WebSocketGateway()"),"."),(0,i.kt)("p",null,"Next, we create a client socket, which gets initialized in the constructor. We\nspecify that we don't want to immediately make the backend connection by\nspecifying the ",(0,i.kt)("inlineCode",{parentName:"p"},"autoConnect")," flag as false. We delay the connection until the\nuser enters their name and hits the connect button in the UI."),(0,i.kt)("p",null,"After the client is defined, we subscribe to a couple of events."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," event is a lifecycle event that gets called automatically on a new\nconnection or reconnection. After an established connection, we fire the\n",(0,i.kt)("inlineCode",{parentName:"p"},"identify")," event, sending the user name so the client can associate the user\nwith the connection. After identifying, we set the ",(0,i.kt)("inlineCode",{parentName:"p"},"connected$")," observable to\ntrue to indicate we have a connection."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"disconnect")," event also runs automatically upon disconnection, and here we\nset the ",(0,i.kt)("inlineCode",{parentName:"p"},"connected$")," back to false."),(0,i.kt)("p",null,"At the end of the constructor, we check to see if we currently have a user name\nset in local storage. If so, we grab it and call the ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," method. This\nallows the browser to refresh or the user to return later and get back into the\nchat room without having to fill out their name again."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," method is called from the app component, which passes in the user.\nIf the client is currently connected, we return early as there's nothing to do.\nIf not, we set the user in local storage, update the ",(0,i.kt)("inlineCode",{parentName:"p"},"user$")," observable with the\nuser name, and initiate a socket connection."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"disconnect")," method clears the local storage, disconnects the client, and\nsets the user to blank."),(0,i.kt)("h3",{id:"appcomponent"},"AppComponent"),(0,i.kt)("p",null,"There are sections of the app component already set up for you. Update the\nhighlighted lines:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=./client/src/app/app.component.ts",title:"./client/src/app/app.component.ts"},"import { Component, OnInit } from '@angular/core';\n//highlight-start\nimport { Observable } from 'rxjs';\nimport { ChatAppData, ChatService } from './chat.service';\n//highlight-end\n\nexport class AppComponent implements OnInit {\n  message = '';\n  user = '';\n  //highlight-next-line\n  chatAppData$!: Observable<ChatAppData>;\n\n  //highlight-next-line\n  constructor(private chatService: ChatService) {}\n\n  ngOnInit(): void {\n    //highlight-next-line\n    this.chatAppData$ = this.chatService.getChatAppData();\n  }\n\n  //highlight-start\n  connect() {\n    if (this.user) {\n      this.chatService.connect(this.user);\n    }\n  }\n\n  disconnect() {\n    this.user = '';\n    this.chatService.disconnect();\n  }\n  //highlight-end\n\n  sendMessage() {}\n}\n")),(0,i.kt)("p",null,"Hopefully, this section is fairly straightforward. We set up a ",(0,i.kt)("inlineCode",{parentName:"p"},"chatAppData$"),"\nobservable, and grab it from the ",(0,i.kt)("inlineCode",{parentName:"p"},"chatService"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"connect")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"disconnect"),"\nmethods are bound to buttons in the template, and the existing ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"user")," variables are bound to text inputs."),(0,i.kt)("h3",{id:"appcomponent-template"},"AppComponent Template"),(0,i.kt)("p",null,"Now it's time to update the template."),(0,i.kt)("p",null,"At the top, update the ",(0,i.kt)("inlineCode",{parentName:"p"},"ng-container")," method to set its ",(0,i.kt)("inlineCode",{parentName:"p"},"ngIf")," statement to bind\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"chatAppData"),". We'll use the ",(0,i.kt)("inlineCode",{parentName:"p"},"async")," pipe to subscribe to the observable and\nalias its return value to ",(0,i.kt)("inlineCode",{parentName:"p"},"data"),", which we will use throughout the rest of the\ntemplate."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:"title=./client/src/app/app.component.html",title:"./client/src/app/app.component.html"},'<ng-container *ngIf="chatAppData$ | async as data"></ng-container>\n')),(0,i.kt)("p",null,"On the next line, update the ",(0,i.kt)("inlineCode",{parentName:"p"},"ngIf")," on the ",(0,i.kt)("inlineCode",{parentName:"p"},"div")," tag to display if\n",(0,i.kt)("inlineCode",{parentName:"p"},"data.connected")," is true:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:"title=./client/src/app/app.component.html",title:"./client/src/app/app.component.html"},'<div *ngIf="data.connected; else login"></div>\n')),(0,i.kt)("p",null,"This displays the chat interface if the user is connected, else it displays the\nconnect form."),(0,i.kt)("p",null,"Next, update line 24 to display the name of the user instead of the hard coded\ntext 'user':"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:"title=./client/src/app/app.component.html",title:"./client/src/app/app.component.html"},'<div class="user">Welcome {{ data.user }}, Room room</div>\n')),(0,i.kt)("p",null,"When you visit the app, you should be able to login/connect and see your name in\nthe welcome message. Reload the page and notice how you stay logged in (thanks\nto the local storage variable). Clicking the disconnect button should return you\nto the login screen."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Initial Chat Screen",src:n(1981).Z,width:"623",height:"701"})),(0,i.kt)("p",null,"That was quite a bit of work to get up and running, but it was the bulk of the\nheavy lifting in getting clients connected and tracking them. Next up, we will\nsee how we can have users join and leave various rooms in the app."))}h.isMDXComponent=!0},1981:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/initial-chat-screen-469a1e61cb7fbf40d305468c45cfc8d4.jpg"}}]);